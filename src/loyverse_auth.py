#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Loyverse OAuthËÆ§ËØÅÊ®°Âùó (‰øÆÂ§çÊùÉÈôêÈóÆÈ¢òÁâàÊú¨)
Â§ÑÁêÜËÆøÈóÆ‰ª§ÁâåÁöÑËé∑Âèñ„ÄÅÂà∑Êñ∞ÂíåÂ≠òÂÇ®
"""

import os
import json
import time
import logging
import pathlib
import tempfile
from typing import Dict, Any, Optional
import httpx

logger = logging.getLogger(__name__)

# ‰øÆÂ§çÊùÉÈôêÈóÆÈ¢òÔºö‰ΩøÁî®‰∏¥Êó∂ÁõÆÂΩïÊàñÁéØÂ¢ÉÂèòÈáèÊåáÂÆöÁöÑË∑ØÂæÑ
def get_token_storage_path() -> pathlib.Path:
    """Ëé∑Âèñ‰ª§ÁâåÂ≠òÂÇ®Ë∑ØÂæÑÔºå‰ºòÂÖà‰ΩøÁî®ÁéØÂ¢ÉÂèòÈáèÔºåÂê¶Âàô‰ΩøÁî®‰∏¥Êó∂ÁõÆÂΩï"""
    storage_dir = os.getenv("TOKEN_STORAGE_PATH")
    if storage_dir:
        # ‰ΩøÁî®ÁéØÂ¢ÉÂèòÈáèÊåáÂÆöÁöÑË∑ØÂæÑ
        base_path = pathlib.Path(storage_dir)
    else:
        # ‰ΩøÁî®Á≥ªÁªü‰∏¥Êó∂ÁõÆÂΩï
        base_path = pathlib.Path(tempfile.gettempdir())
    
    return base_path / "loyverse_token.json"

# Âä®ÊÄÅËé∑Âèñ‰ª§ÁâåÊñá‰ª∂Ë∑ØÂæÑ
TOKEN_FILE = get_token_storage_path()

# OAuthÁ´ØÁÇπ
OAUTH_TOKEN_URL = "https://api.loyverse.com/oauth/token"

# APIË∂ÖÊó∂ËÆæÁΩÆ
AUTH_TIMEOUT = 15.0

def save_token(token_data: Dict[str, Any]) -> None:
    """
    ‰øùÂ≠ò‰ª§ÁâåÊï∞ÊçÆÂà∞Êñá‰ª∂ (‰øÆÂ§çÊùÉÈôêÈóÆÈ¢òÁâàÊú¨)
    
    Args:
        token_data: ‰ª§ÁâåÊï∞ÊçÆÂ≠óÂÖ∏
    """
    try:
        # ÈáçÊñ∞Ëé∑ÂèñÂΩìÂâçË∑ØÂæÑ (ÂèØËÉΩÁéØÂ¢ÉÂèòÈáèÂ∑≤Êõ¥Êñ∞)
        current_token_file = get_token_storage_path()
        
        # Á°Æ‰øùÁà∂ÁõÆÂΩïÂ≠òÂú®
        parent_dir = current_token_file.parent
        if not parent_dir.exists():
            try:
                parent_dir.mkdir(parents=True, exist_ok=True)
                logger.debug(f"üìÅ Created directory: {parent_dir}")
            except PermissionError:
                # Â¶ÇÊûúÂàõÂª∫Â§±Ë¥•ÔºåÂ∞ùËØï‰ΩøÁî®‰∏¥Êó∂ÁõÆÂΩï
                temp_dir = pathlib.Path(tempfile.gettempdir())
                current_token_file = temp_dir / "loyverse_token.json"
                logger.warning(f"‚ö†Ô∏è Permission denied, using temp file: {current_token_file}")
        
        # ÂÜôÂÖ•‰ª§ÁâåÊï∞ÊçÆ
        with open(current_token_file, 'w', encoding='utf-8') as f:
            json.dump(token_data, f, indent=2)
        
        # Â∞ùËØïËÆæÁΩÆÊñá‰ª∂ÊùÉÈôêÔºàÂ¶ÇÊûúÊîØÊåÅÔºâ
        try:
            current_token_file.chmod(0o600)
        except (OSError, AttributeError):
            # Âú®Êüê‰∫õÁ≥ªÁªü‰∏äÂèØËÉΩ‰∏çÊîØÊåÅchmod
            logger.debug("‚ö†Ô∏è Cannot set file permissions (not supported)")
        
        logger.debug(f"üíæ Token saved successfully to: {current_token_file}")
        
        # Êõ¥Êñ∞ÂÖ®Â±ÄTOKEN_FILEÂèòÈáè
        global TOKEN_FILE
        TOKEN_FILE = current_token_file
        
    except Exception as e:
        logger.error(f"Failed to save token: {e}")
        # Â∞ùËØïÊúÄÂêéÁöÑÂ§áÁî®ÊñπÊ°àÔºöÂÜÖÂ≠òÂ≠òÂÇ®
        try:
            _store_token_in_memory(token_data)
            logger.warning("üíæ Token stored in memory as fallback")
        except:
            raise Exception(f"Failed to save token: {str(e)}")

def load_token() -> Dict[str, Any]:
    """
    ‰ªéÊñá‰ª∂Âä†ËΩΩ‰ª§ÁâåÊï∞ÊçÆ (‰øÆÂ§çÊùÉÈôêÈóÆÈ¢òÁâàÊú¨)
    
    Returns:
        ‰ª§ÁâåÊï∞ÊçÆÂ≠óÂÖ∏ÔºåÂ¶ÇÊûúÊñá‰ª∂‰∏çÂ≠òÂú®ËøîÂõûÁ©∫Â≠óÂÖ∏
    """
    try:
        # ÈáçÊñ∞Ëé∑ÂèñÂΩìÂâçË∑ØÂæÑ
        current_token_file = get_token_storage_path()
        
        # Ê£ÄÊü•ÂÖ®Â±ÄTOKEN_FILEÊòØÂê¶Â≠òÂú®‰∏î‰∏çÂêå
        if TOKEN_FILE != current_token_file and TOKEN_FILE.exists():
            current_token_file = TOKEN_FILE
        
        if current_token_file.exists():
            with open(current_token_file, 'r', encoding='utf-8') as f:
                token_data = json.load(f)
            logger.debug(f"üìñ Token loaded from: {current_token_file}")
            return token_data
        else:
            # Â∞ùËØï‰ªéÂÜÖÂ≠òÂä†ËΩΩ
            memory_token = _load_token_from_memory()
            if memory_token:
                logger.debug("üìñ Token loaded from memory")
                return memory_token
            
            logger.debug(f"üìÑ No token file found at: {current_token_file}")
            return {}
            
    except json.JSONDecodeError as e:
        logger.error(f"Token file corrupted: {e}")
        # Âà†Èô§ÊçüÂùèÁöÑÊñá‰ª∂
        try:
            current_token_file = get_token_storage_path()
            if current_token_file.exists():
                current_token_file.unlink()
        except:
            pass
        return {}
        
    except Exception as e:
        logger.error(f"Failed to load token: {e}")
        # Â∞ùËØï‰ªéÂÜÖÂ≠òÂä†ËΩΩ
        memory_token = _load_token_from_memory()
        if memory_token:
            return memory_token
        return {}

# ÂÜÖÂ≠òÂ≠òÂÇ®Â§áÁî®ÊñπÊ°à
_memory_token_storage = {}

def _store_token_in_memory(token_data: Dict[str, Any]) -> None:
    """Âú®ÂÜÖÂ≠ò‰∏≠Â≠òÂÇ®‰ª§Áâå‰Ωú‰∏∫Â§áÁî®ÊñπÊ°à"""
    global _memory_token_storage
    _memory_token_storage = token_data.copy()

def _load_token_from_memory() -> Dict[str, Any]:
    """‰ªéÂÜÖÂ≠òÂä†ËΩΩ‰ª§Áâå"""
    return _memory_token_storage.copy()

def refresh_access_token() -> str:
    """
    Âà∑Êñ∞ËÆøÈóÆ‰ª§Áâå
    
    Returns:
        Êñ∞ÁöÑËÆøÈóÆ‰ª§Áâå
        
    Raises:
        Exception: ÂΩìÂà∑Êñ∞Â§±Ë¥•Êó∂
    """
    try:
        logger.info("üîÑ Refreshing Loyverse access token")
        
        # Ëé∑ÂèñÂà∑Êñ∞‰ª§Áâå
        refresh_token = get_refresh_token()
        if not refresh_token:
            raise ValueError("No refresh token available")
        
        # Ëé∑ÂèñOAuthÈÖçÁΩÆ
        client_id = os.getenv("LOYVERSE_CLIENT_ID")
        client_secret = os.getenv("LOYVERSE_CLIENT_SECRET")
        
        if not client_id or not client_secret:
            raise ValueError("Missing OAuth credentials (LOYVERSE_CLIENT_ID or LOYVERSE_CLIENT_SECRET)")
        
        # ÊûÑÂª∫ËØ∑Ê±ÇÊï∞ÊçÆ
        token_request_data = {
            "grant_type": "refresh_token",
            "refresh_token": refresh_token,
            "client_id": client_id,
            "client_secret": client_secret
        }
        
        logger.debug(f"üåê Requesting token from {OAUTH_TOKEN_URL}")
        
        # ÂèëÈÄÅËØ∑Ê±Ç
        with httpx.Client(timeout=AUTH_TIMEOUT) as client:
            response = client.post(
                OAUTH_TOKEN_URL,
                data=token_request_data,
                headers={"Content-Type": "application/x-www-form-urlencoded"}
            )
            
            response.raise_for_status()
            
            # Ëß£ÊûêÂìçÂ∫î
            token_data = response.json()
            
            # È™åËØÅÂìçÂ∫îÊï∞ÊçÆ
            if "access_token" not in token_data:
                raise ValueError("No access_token in response")
            
            # ËÆ°ÁÆóËøáÊúüÊó∂Èó¥
            expires_in = token_data.get("expires_in", 3500)  # ÈªòËÆ§Êé•Ëøë1Â∞èÊó∂
            token_data["expires_at"] = int(time.time()) + expires_in - 60  # ÊèêÂâç1ÂàÜÈíü
            
            # ‰øùÂ≠òÊñ∞‰ª§Áâå
            save_token(token_data)
            
            access_token = token_data["access_token"]
            logger.info(f"‚úÖ Access token refreshed successfully (expires in {expires_in}s)")
            
            return access_token
            
    except httpx.HTTPStatusError as e:
        error_msg = f"OAuth HTTP error: {e.response.status_code}"
        try:
            error_detail = e.response.json()
            error_msg += f" - {error_detail}"
        except:
            error_msg += f" - {e.response.text}"
        
        logger.error(error_msg)
        raise Exception(error_msg)
        
    except httpx.TimeoutException:
        error_msg = "OAuth request timeout"
        logger.error(error_msg)
        raise Exception(error_msg)
        
    except Exception as e:
        error_msg = f"Failed to refresh token: {str(e)}"
        logger.error(error_msg)
        raise Exception(error_msg)

def get_refresh_token() -> Optional[str]:
    """
    Ëé∑ÂèñÂà∑Êñ∞‰ª§Áâå
    
    Returns:
        Âà∑Êñ∞‰ª§ÁâåÔºå‰ºòÂÖà‰ªéÁéØÂ¢ÉÂèòÈáèËé∑ÂèñÔºåÁÑ∂Âêé‰ªéÊñá‰ª∂Ëé∑Âèñ
    """
    # ‰ºòÂÖà‰ΩøÁî®ÁéØÂ¢ÉÂèòÈáè‰∏≠ÁöÑÂà∑Êñ∞‰ª§Áâå
    refresh_token = os.getenv("LOYVERSE_REFRESH_TOKEN")
    if refresh_token:
        logger.debug("üîë Using refresh token from environment")
        return refresh_token
    
    # ‰ªéÊñá‰ª∂Ëé∑Âèñ
    token_data = load_token()
    refresh_token = token_data.get("refresh_token")
    if refresh_token:
        logger.debug("üîë Using refresh token from file")
        return refresh_token
    
    logger.warning("‚ö†Ô∏è No refresh token found")
    return None

def get_access_token() -> str:
    """
    Ëé∑ÂèñÊúâÊïàÁöÑËÆøÈóÆ‰ª§Áâå
    Â¶ÇÊûúÂΩìÂâç‰ª§ÁâåÂç≥Â∞ÜËøáÊúüÊàñÂ∑≤ËøáÊúüÔºå‰ºöËá™Âä®Âà∑Êñ∞
    
    Returns:
        ÊúâÊïàÁöÑËÆøÈóÆ‰ª§Áâå
        
    Raises:
        Exception: ÂΩìÊó†Ê≥ïËé∑Âèñ‰ª§ÁâåÊó∂
    """
    try:
        # Âä†ËΩΩÁé∞Êúâ‰ª§Áâå
        token_data = load_token()
        
        # Ê£ÄÊü•‰ª§ÁâåÊòØÂê¶ÊúâÊïà
        if is_token_valid(token_data):
            access_token = token_data["access_token"]
            logger.debug("‚úÖ Using existing valid access token")
            return access_token
        
        # ‰ª§ÁâåÊó†ÊïàÊàñÂç≥Â∞ÜËøáÊúüÔºåÈúÄË¶ÅÂà∑Êñ∞
        logger.info("üîÑ Access token expired or invalid, refreshing...")
        return refresh_access_token()
        
    except Exception as e:
        logger.error(f"Failed to get access token: {e}")
        raise Exception(f"Failed to get access token: {str(e)}")

def is_token_valid(token_data: Dict[str, Any]) -> bool:
    """
    Ê£ÄÊü•‰ª§ÁâåÊòØÂê¶ÊúâÊïà
    
    Args:
        token_data: ‰ª§ÁâåÊï∞ÊçÆ
        
    Returns:
        ‰ª§ÁâåÊòØÂê¶ÊúâÊïà
    """
    if not token_data:
        return False
    
    # Ê£ÄÊü•ÂøÖË¶ÅÂ≠óÊÆµ
    if "access_token" not in token_data or "expires_at" not in token_data:
        return False
    
    # Ê£ÄÊü•ÊòØÂê¶ËøáÊúüÔºàÊèêÂâç60ÁßíÂà§Êñ≠Ôºâ
    current_time = int(time.time())
    expires_at = token_data.get("expires_at", 0)
    
    if current_time >= expires_at:
        logger.debug("‚è∞ Token expired or expiring soon")
        return False
    
    # ËÆ°ÁÆóÂâ©‰ΩôÊó∂Èó¥
    remaining_time = expires_at - current_time
    logger.debug(f"‚è≥ Token valid for {remaining_time} more seconds")
    
    return True

def revoke_token() -> bool:
    """
    Êí§ÈîÄÂΩìÂâç‰ª§Áâå
    
    Returns:
        ÊòØÂê¶ÊàêÂäüÊí§ÈîÄ
    """
    try:
        token_data = load_token()
        access_token = token_data.get("access_token")
        
        if not access_token:
            logger.info("üö´ No token to revoke")
            return True
        
        # Âà†Èô§Êú¨Âú∞‰ª§ÁâåÊñá‰ª∂
        try:
            current_token_file = get_token_storage_path()
            if current_token_file.exists():
                current_token_file.unlink()
                logger.info("üóëÔ∏è Local token file deleted")
        except FileNotFoundError:
            pass
        except Exception as e:
            logger.warning(f"Could not delete token file: {e}")
        
        # Ê∏ÖÈô§ÂÜÖÂ≠òÂ≠òÂÇ®
        global _memory_token_storage
        _memory_token_storage = {}
        
        logger.info("‚úÖ Token revoked successfully")
        return True
        
    except Exception as e:
        logger.error(f"Failed to revoke token: {e}")
        return False

def get_token_info() -> Dict[str, Any]:
    """
    Ëé∑Âèñ‰ª§Áâå‰ø°ÊÅØÔºàÁî®‰∫éË∞ÉËØïÂíåÁõëÊéßÔºâ
    
    Returns:
        ‰ª§Áâå‰ø°ÊÅØÂ≠óÂÖ∏
    """
    try:
        token_data = load_token()
        current_token_file = get_token_storage_path()
        
        if not token_data:
            return {
                "status": "no_token",
                "file_path": str(current_token_file),
                "has_file": current_token_file.exists(),
                "has_env_refresh_token": bool(os.getenv("LOYVERSE_REFRESH_TOKEN")),
                "has_memory_token": bool(_memory_token_storage)
            }
        
        current_time = int(time.time())
        expires_at = token_data.get("expires_at", 0)
        remaining_time = max(0, expires_at - current_time)
        
        return {
            "status": "valid" if is_token_valid(token_data) else "expired",
            "has_access_token": bool(token_data.get("access_token")),
            "has_refresh_token": bool(token_data.get("refresh_token")),
            "expires_at": expires_at,
            "remaining_seconds": remaining_time,
            "file_path": str(current_token_file),
            "file_exists": current_token_file.exists(),
            "storage_method": "file" if current_token_file.exists() else "memory"
        }
        
    except Exception as e:
        return {
            "status": "error",
            "error": str(e)
        }

def initialize_oauth_from_env() -> bool:
    """
    ‰ªéÁéØÂ¢ÉÂèòÈáèÂàùÂßãÂåñOAuth‰ª§Áâå
    Áî®‰∫éÈ¶ñÊ¨°ËÆæÁΩÆÊàñÈáçÁΩÆ‰ª§Áâå
    
    Returns:
        ÊòØÂê¶ÊàêÂäüÂàùÂßãÂåñ
    """
    try:
        refresh_token = os.getenv("LOYVERSE_REFRESH_TOKEN")
        if not refresh_token:
            logger.warning("‚ö†Ô∏è LOYVERSE_REFRESH_TOKEN not found in environment")
            return False
        
        # ÂàõÂª∫ÂàùÂßã‰ª§ÁâåÊï∞ÊçÆ
        initial_token_data = {
            "refresh_token": refresh_token,
            "expires_at": 0  # Âº∫Âà∂Âà∑Êñ∞
        }
        
        save_token(initial_token_data)
        logger.info("üéØ OAuth initialized from environment variables")
        
        # Á´ãÂç≥Ëé∑ÂèñËÆøÈóÆ‰ª§Áâå
        get_access_token()
        
        return True
        
    except Exception as e:
        logger.error(f"Failed to initialize OAuth from environment: {e}")
        return False

def test_token_storage() -> Dict[str, Any]:
    """
    ÊµãËØï‰ª§ÁâåÂ≠òÂÇ®ÂäüËÉΩ
    
    Returns:
        ÊµãËØïÁªìÊûú
    """
    try:
        test_data = {
            "test": "token_storage_test",
            "timestamp": int(time.time())
        }
        
        # ÊµãËØï‰øùÂ≠ò
        save_token(test_data)
        
        # ÊµãËØïÂä†ËΩΩ
        loaded_data = load_token()
        
        # È™åËØÅÊï∞ÊçÆ
        success = loaded_data.get("test") == "token_storage_test"
        
        # Ê∏ÖÁêÜÊµãËØïÊï∞ÊçÆ
        if success:
            revoke_token()
        
        return {
            "success": success,
            "storage_path": str(get_token_storage_path()),
            "loaded_data": loaded_data
        }
        
    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "storage_path": str(get_token_storage_path())
        }
